% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/translate.R
\name{translate}
\alias{translate}
\alias{decipher}
\title{translate}
\usage{
translate(s, key, flexible = TRUE, within = FALSE, rep1w = TRUE,
  f2c = TRUE)

decipher(s, key, flexible = TRUE, within = FALSE, rep1w = TRUE,
  f2c = TRUE)
}
\arguments{
\item{s}{vector to translate}

\item{key}{translation key}

\item{flexible}{allow the key to be inversed if that seems more plausible?}

\item{within}{logical; use \code{gsub} to translate within strings?}

\item{rep1w}{logical; if \code{within = TRUE}, should replacement within
particular entry occur only once?}

\item{f2c}{should factors be as character? (default \code{TRUE})}
}
\value{
vector
}
\description{
translate by key
}
\details{
if you  have a key \code{key <- c('a'  = 'A', 'b' = 'B')} you  can use it to
    translate \code{s  <- c('a', 'b',  'a')} to \code{c('A', 'B',  'A')} via
    \code{key[v]}, which is  nice. But if \code{s <- c('a',  'b', 'c')} then
    \code{key[s]} is  \code{c('A', 'B', NA)}. The  function \code{translate}
    will  make sure  that translations  occur whenever  a corresponding  key
    entry exists, else keep the orginal value.
}
\examples{
kEy = c("foo" = "Foo la la", "bar" = "Bar di da",
        "baz" = "baz", "quz" = "Quz")
sset = c("foo", "bar", "baz", "quz")[c(2,1,1,4,1,2,2,3,2,3)]
table(new = translate(s = sset, key = kEy), old = sset, useNA = "ifany")
sset = c("Foo la la", "baz", "Quz")
table(new = translate(s = sset, key = kEy), old = sset, useNA = "ifany")
## 'within = TRUE' uses gsub to look WITHIN strings
KeY <- c("foo" = "The Foo", "bar" = "The Bar", "a" = "A")
sset <- c("I have foo", "no bar today", "i got an a", "foo", "a bar")
translate(s = sset, key = KeY, within = TRUE, rep1w = TRUE)
translate(s = sset, key = KeY, within = TRUE, rep1w = FALSE)
translate(s = sset, key = KeY, within = FALSE, rep1w = TRUE)
}
