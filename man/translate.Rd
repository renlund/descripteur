% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/translate.R
\name{translate}
\alias{translate}
\alias{decipher}
\title{translate}
\usage{
translate(s, key, flexible = TRUE)

decipher(s, key, flexible = TRUE)
}
\arguments{
\item{s}{vector to translate}

\item{key}{translation key}

\item{flexible}{allow a key to be inversed if that seems more plausible?}
}
\value{
vector
}
\description{
translate by key
}
\details{
if you  have a key \code{key <- c('a'  = 'A', 'b' = 'B')} you  can use it to
    translate \code{s  <- c('a', 'b',  'a')} to \code{c('A', 'B',  'A')} via
    \code{key[v]}, which is  nice. But if \code{s <- c('a',  'b', 'c')} then
    \code{key[s]} is  \code{c('A', 'B', NA)}. The  function \code{translate}
    will  make sure  that translations  occur whenever  a corresponding  key
    entry exists, else keep the orginal value.
}
\examples{
kEy = c("foo" = "Foo la la", "bar" = "Bar di da",
        "baz" = "baz", "quz" = "Quz")
sset = c("foo", "bar", "baz", "quz")[c(2,1,1,4,1,2,2,3,2,3)]
table(new = translate(s = sset, key = kEy), old = sset, useNA = "ifany")
sset = c("Foo la la", "baz", "Quz")
table(new = translate(s = sset, key = kEy), old = sset, useNA = "ifany")
}
